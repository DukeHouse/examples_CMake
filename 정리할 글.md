awesome-cmake  https://github.com/onqtam/awesome-cmake
cmake-tutorial https://github.com/pyk/cmake-tutorial
cmake-examples https://github.com/ttroy50/cmake-examples
cmake_cookbook https://github.com/mechazoidal/cmake_cookbook  
ZeroMQ, minizip 등의 외부 라이브러리를 사용하는 예제 코드가 있음.
dev-cafe/cmake-cookbook https://github.com/dev-cafe/cmake-cookbook
cross platform cmake project template https://github.com/nekko1119/CMakeProjectTemplate
(한글)luncliff/cmake-tutorial.md   https://gist.github.com/luncliff/6e2d4eb7ca29a0afd5b592f72b80cb5c
(일어)라이브러리를 자동적으로 찾는 Find<package>.cmake 템플릿  https://qiita.com/shohirose/items/d9bda00a39a113965c5c
CMake Advent Calendar 2014  https://qiita.com/advent-calendar/2014/cmake
(일어)CMake: 프리컴파일드 헤더 작성과 이용    https://qiita.com/mrk_21/items/264f6135679239ff018a
Linking GLEW with CMake https://stackoverflow.com/questions/27472813/linking-glew-with-cmake
(일어)CMake에서  멀티플랫폼 개발(라즈베리 파이용 크로스 컴파일 포함)  https://qiita.com/take-iwiw/items/50a47dd3ff3e9163de0d
(일어)CMake에서 CUDA 애플리케이션 개발  https://qiita.com/take-iwiw/items/a29f017ea05fec77f8e1
(일어)CMake에서 OpenCV 애플리케이션 개발  https://qiita.com/take-iwiw/items/337dce2148b3d6cee560
(일어)c++14 with openmp + gtest-1.8의 cmake 환경을 준비  https://qiita.com/takeshi-uchitane/items/04f558cb405245cfabea
(일어)ccache http://qiita.com/tags/ccache/items 
(일어)cmake에서 빌드 시에 쉘 스크립트를 실행하기  http://qiita.com/termoshtt/items/7f7090f9d0c52bcd2630
cmake에서 정적 라이브러리를 하나로 합치기 http://ospace.tistory.com/539
Bootstrapping a vcpkg-based cmake project in Visual Studio  http://cpptruths.blogspot.com/2019/03/bootstrapping-vcpkg-based-cmake-project.html
Bootstrapping a vcpkg-based project in Linux and Windows with idiomatic cmake  http://cpptruths.blogspot.com/2019/03/bootstrapping-vcpkg-based-cmake-project_31.html

업그레이드 하기
패키지로 설치 되는 것보다 더 높은 버전을 원한다면 직접 설치해야 한다.

현재(2018.11) 최신 버전은 3.13.0 버전이고, 이 비전의 소스를 다운로드 한다. 
다운로드 주소는 https://cmake.org/download/ 에서 알 수 있다.



다운로드 한다.
  $ wget https://cmake.org/files/v3.13/cmake-3.13.0.tar.gz

압축을 푼다
  $ tar -zxvf cmake-3.13.0.tar.gz

빌드 후 설치한다
  $ cd cmake-3.13.0
  $ ./bootstrap
  $ make
  $ sudo make install



설치는 /usr/local/bin 에 설치된다





C++14로 컴파일 하기
enable_language(CXX)
set(CMAKE_CXX_STANDARD 14) # C++14...
set(CMAKE_CXX_STANDARD_REQUIRED ON) #...is required...
set(CMAKE_CXX_EXTENSIONS OFF) #...without compiler extensions like gnu++11
CMAKE_CXX_STANDARDに11, 14, 17 로 지정한다.

CMAKE_CXX_EXTENSIONS을 OFF로 하지 않으면 GNU 확장이 사용된다. 

경고 레벨
Visual C++ 이라면 /W4, GCC/Clang 이라면 -Wall -Wextra 를 붙인다.

if(MSVC)
  # Force to always compile with W4
  if(CMAKE_CXX_FLAGS MATCHES "/W[0-4]")
    string(REGEX REPLACE "/W[0-4]" "/W4" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
  else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4")
  endif()
elseif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)
  # Update if necessary
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wno-long-long -pedantic")
endif()




자주 사용하는 옵션
옵션으로 자주 사용하는 것이라면 최적화 옵션 O 나 c ++ 11/14/17 기능을 활성화 하는 -std=c++11/14/1z 와 -Wall 등의 경고 옵션.

명령 줄에서 빌드하는 경우, 예를 들면 이런 식으로 옵션을 추가한다.

g++ -O2 -std = c ++ 11 -Wall ... (기타 다양한 부가)

 
Tips
Makefile 에서 += 라는 것을 CMake에서 어떻게 기술?
예를들면 Makefile 에서
  SRCS += hoge.c
라는 것은  
  set(SRCS ${SRCS} hoge.c)  

컴파일러 플래그에 세미콜롬(';')을 넣어서 빌드가 중단 되었다
CMake는 내부에서는 리스트를 세미콜롬 구별 문자열로 정리하고 있으므로 이것을 컴파일러에 넘기면 세미컬럼이 남겨져 버린다.  
이런 경우 ""로 구별하는 것으로 세미콜롬 구별을 스페이스 구별로 변환해 준다.  

  CFLAGS += -g
 
라는 Makefile 에서 쓴 것을  
 
  set (CMAKE_C_FLAGS ${CMAKE_C_FLAGS} "-g")
라고 하면 세미콜롬이 들어가서 죽는다.  

set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g")
로 하면 OK.    
타겟 이름을 libhoge로 해서 라이브러리를 빌드하면 liblibhoge.so 로 된다 
빌드 후에 파일의 복사하는 것이 아닌 set_target_property()를 사용하여 OUTPUT_NAME 속성을 변경하면 좋다  
단 선두의 "lib"만을 제거하는 것은 더 간단하므로 PREFIX 속성을 조작하면 삭제 OK.  

set (TARGET_NAME libhoge)
add_library (${TARGET_NAME} SHARED hoge.c hoge2.c)
set_target_properties (${TARGET_NAME}
                       PROPERTIES PREFIX
                       "")